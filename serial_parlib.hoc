// serial_parlib.hoc
// is a serial version of the parlib.hoc parallel library file
// intended to track gid's for the serial version solely for netcon event recording
// that will allow comparison with the parallel versions's spike recording

objref nil
{load_file("stdlib.hoc") } // need String

// map functions between gid and (type, iXD, jYD)
// original serial program creates
//objref PL5[X_DIM][Y_DIM]
//objref PL2[X_DIM][Y_DIM]
//objref IPL2[X_DIM][Y_DIM]
//objref IPL5[X_DIM][Y_DIM]
//Although some of the IPL are empty because of zigzag there is no reason
//to have contiguous gids so we start with a simple map.

// type ranges from 0 to 3 and refers to PL5, PL2, IPL2, IPL5
gid_end = N_TYPE*X_DIM*Y_DIM // NOT the number of cells (because of zigzag)
PL5_type = 0
PL2_type = 1
IPL2_type = 2
IPL5_type = 3
N_ALPHA = 150
FF_type = 4
FB_type = 5
gidAlphabegin = 400
FFgid = 701
FBgid = 702
FF2gid = 703

//gid = type2gid(type, ixd, jyd)
func type2gid() {local type, ixd, jyd, gid
	type = $1  ixd = $2  jyd = $3
	if (type < FF_type) {
		gid = type * X_DIM * Y_DIM  +  ixd * Y_DIM + jyd
	}else if (type <= FB_type) {
		gid = gidAlphabegin + (type - FF_type)*N_ALPHA + ixd
	}else{
		gid = type
	}
	return gid
}

// sprinkle want_spike(cell, type, ixd, jyd)
// whereever the serial code creates cells

objref tvec, idvec
tvec = new Vector()
idvec=new Vector()
proc want_spike() {localobj nc, nil
//  if ($2 < 2) {  // type pyr's have soma and the inhib's have cell as section name to watch
//	$o1.soma nc = new NetCon(&v(0.5), nil)
//  } else {
//	$o1.cell nc = new NetCon(&v(0.5), nil)
//  }
   $o1.connect2target(nil, nc)
  nc.record(tvec, idvec, type2gid($2, $3, $4))
}

proc spikeout() {local rank, i  localobj f
	f = new File("out.dat")
	f.aopen()
	for i=0, idvec.size-1 {
		f.printf("%.3f %d\n", tvec.x[i], idvec.x[i])
		}
	f.close()
}


